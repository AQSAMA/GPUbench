<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mandelbulb Stress Benchmark</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; color: #0f0; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; width: 100%; height: 100%; }
        #hud {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box;
            text-shadow: 0 0 5px #0f0; font-size: 14px;
        }
        .row { display: flex; justify-content: space-between; align-items: flex-start; }
        .data-block { background: rgba(0, 20, 0, 0.8); padding: 10px; border: 1px solid #0f0; }
        h1 { margin: 0 0 5px 0; font-size: 18px; text-transform: uppercase; border-bottom: 1px solid #0f0; padding-bottom: 5px; }
        .stat { display: flex; justify-content: space-between; gap: 20px; }
        .stat span:last-child { font-weight: bold; }
        #instructions { font-size: 12px; opacity: 0.8; text-align: center; pointer-events: auto; cursor: pointer; }
        #warning {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 48px; color: red; border: 5px solid red; padding: 20px; background: #000;
            display: none; text-align: center; z-index: 999; animation: flash 0.2s infinite;
        }
        @keyframes flash { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
    </style>
</head>
<body>

    <canvas id="glCanvas"></canvas>

    <div id="hud">
        <div class="row">
            <div class="data-block">
                <h1>System Metrics</h1>
                <div class="stat"><span>FPS:</span><span id="fps">0</span></div>
                <div class="stat"><span>Frame Time:</span><span id="ms">0 ms</span></div>
                <div class="stat"><span>Total Frames:</span><span id="frames">0</span></div>
                <div class="stat"><span>Elapsed:</span><span id="timer">0.00s</span></div>
            </div>
            <div class="data-block" style="text-align: right;">
                <h1>Benchmark Status</h1>
                <div class="stat"><span>Load:</span><span id="load">0%</span></div>
                <div class="stat"><span>Res Scale:</span><span id="resScale">1.0x</span></div>
                <div class="stat" style="color: #fff;"><span>Est. GFLOPS:</span><span id="gflops">CALC</span></div>
            </div>
        </div>

        <div id="warning">SYSTEM OVERLOAD</div>

        <div class="row" style="align-items: flex-end;">
            <div class="data-block">
                <h1>Ray Parameters</h1>
                <div class="stat"><span>Max Steps:</span><span id="steps">0</span></div>
                <div class="stat"><span>Epsilon:</span><span id="epsilon">0.0000</span></div>
                <div class="stat"><span>Fractal Iter:</span><span id="iter">0</span></div>
                <div class="stat"><span>AO Samples:</span><span id="ao">0</span></div>
            </div>
            <div id="instructions" class="data-block">
                [DRAG] Rotate | [SCROLL/PINCH] Zoom | [WASD] Pan<br>
                [DOUBLE TAP] Reset | Experience auto-intensifies.<br>
                Survive 60 seconds if you can.
            </div>
        </div>
    </div>

<script>
/**
 * MANDELBULB STRESS TEST
 * Designed to transition from mobile-friendly to GPU-melting exponentially.
 */

const canvas = document.getElementById('glCanvas');
const gl = canvas.getContext('webgl2', { powerPreference: "high-performance" });

if (!gl) {
    document.body.innerHTML = "<h1 style='color:white; padding:20px;'>WebGL 2.0 not supported. Your device is too old for this benchmark.</h1>";
    throw new Error("WebGL 2 missing");
}

// --- SHADER SOURCES ---

const vsSource = `#version 300 es
in vec4 a_position;
void main() {
    gl_Position = a_position;
}`;

const fsSource = `#version 300 es
precision highp float;

uniform vec2 u_resolution;
uniform float u_time;
uniform vec3 u_camPos;
uniform vec3 u_camTarget;
uniform float u_zoom;

// Difficulty Uniforms
uniform int u_maxSteps;
uniform float u_epsilon;
uniform int u_fractalIter;
uniform float u_power;
uniform int u_aoSamples;

out vec4 outColor;

// Matrix helpers
mat3 setCamera(in vec3 ro, in vec3 ta, float cr) {
    vec3 cw = normalize(ta-ro);
    vec3 cp = vec3(sin(cr), cos(cr),0.0);
    vec3 cu = normalize( cross(cw,cp) );
    vec3 cv =          ( cross(cu,cw) );
    return mat3( cu, cv, cw );
}

// Mandelbulb Distance Estimator
float map(vec3 pos) {
    vec3 w = pos;
    float m = dot(w,w);
    float dz = 1.0;
    float r = 0.0;
    
    // Dynamic iteration count determines arithmetic intensity
    for(int i=0; i<25; i++) {
        if(i >= u_fractalIter) break;

        r = length(w);
        if(r > 2.0) break;

        // Polynomial expansion for derivatives
        float p = u_power;
        dz = p * pow(r, p - 1.0) * dz + 1.0;
        
        // Cartesian to Polar
        float theta = acos(w.z / r);
        float phi = atan(w.y, w.x);
        
        // Scale and Rotate
        float zr = pow(r, p);
        theta = theta * p + u_time * 0.1; // Animate the fractal fold
        phi = phi * p + u_time * 0.05;
        
        // Polar to Cartesian
        w = zr * vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));
        w += pos;
        
        if (m > 4.0) break; // Bailout optimization (or lack thereof for stress)
    }
    
    return 0.5 * log(r) * r / dz;
}

// Soft shadows and AO - Expensive!
float calcAO(in vec3 pos, in vec3 nor) {
    float occ = 0.0;
    float sca = 1.0;
    for(int i=0; i<10; i++) {
        if(i >= u_aoSamples) break;
        float h = 0.01 + 0.12*float(i)/float(u_aoSamples);
        float d = map(pos + h*nor);
        occ += (h-d)*sca;
        sca *= 0.95;
        if(occ > 0.35) break;
    }
    return clamp(1.0 - 3.0*occ, 0.0, 1.0) * (0.5+0.5*nor.y);
}

void main() {
    vec2 p = (2.0*gl_FragCoord.xy - u_resolution.xy) / u_resolution.y;

    // Camera Setup
    vec3 ro = u_camPos;
    vec3 ta = u_camTarget;
    mat3 ca = setCamera(ro, ta, 0.0);
    
    // Ray Direction with Zoom
    vec3 rd = ca * normalize(vec3(p.xy, u_zoom));

    // Raymarching
    float t = 0.0;
    float d = 0.0;
    int steps = 0;
    bool hit = false;
    
    // Glow accumulator
    float glow = 0.0;

    for(int i=0; i<5000; i++) {
        if(i >= u_maxSteps) break;
        
        vec3 pos = ro + t*rd;
        d = map(pos);
        
        // Accumulate glow based on closeness to fractal
        glow += exp(-d * 10.0) * 0.05; 

        if(d < u_epsilon) {
            hit = true;
            break;
        }
        t += d;
        if(t > 20.0) break;
        steps = i;
    }

    vec3 col = vec3(0.0);

    if(hit) {
        vec3 pos = ro + t*rd;
        // Approximate Normal (expensive version)
        vec2 e = vec2(u_epsilon * 2.0, 0.0); // Gradient step depends on epsilon
        vec3 nor = normalize(vec3(
            map(pos+e.xyy) - map(pos-e.xyy),
            map(pos+e.yxy) - map(pos-e.yxy),
            map(pos+e.yyx) - map(pos-e.yyx)
        ));

        // Lighting
        vec3 lig = normalize(vec3(0.8, 0.6, -0.4));
        float dif = clamp(dot(nor, lig), 0.0, 1.0);
        float amb = 0.5 + 0.5*dot(nor, vec3(0.0,1.0,0.0));
        
        // Material Color (Palette based on orbit trap logic sim)
        vec3 mate = vec3(0.2, 0.2, 0.2);
        mate += 0.3 * cos(vec3(0.0, 1.0, 2.0) + length(pos)*2.0);

        // Ambient Occlusion
        float occ = calcAO(pos, nor);

        col = mate * dif * occ;
        col += mate * amb * 0.2 * occ;
        
        // Fog
        col = mix(col, vec3(0.0), 1.0 - exp(-0.1*t));
    } else {
        // Background space dust
        col = vec3(0.05) * (1.0 - length(p)*0.5);
    }

    // Add glow
    col += vec3(0.2, 0.5, 1.0) * glow * 0.01 * (float(steps)/float(u_maxSteps));
    
    // Iteration Heatmap Overlay (for benchmarking visual feedback)
    float stress = float(steps) / float(u_maxSteps);
    col = mix(col, vec3(1.0, 0.0, 0.0), stress * stress * 0.3);

    // Gamma
    col = pow(col, vec3(0.4545));

    outColor = vec4(col, 1.0);
}
`;

// --- WEBGL BOILERPLATE ---

function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
    }
    return shader;
}

const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);

if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(program));
}

const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1, -1,
     1, -1,
    -1,  1,
    -1,  1,
     1, -1,
     1,  1,
]), gl.STATIC_DRAW);

const vao = gl.createVertexArray();
gl.bindVertexArray(vao);
gl.enableVertexAttribArray(positionAttributeLocation);
gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

// --- UNIFORM LOCATIONS ---

const locs = {
    res: gl.getUniformLocation(program, "u_resolution"),
    time: gl.getUniformLocation(program, "u_time"),
    camPos: gl.getUniformLocation(program, "u_camPos"),
    camTarget: gl.getUniformLocation(program, "u_camTarget"),
    zoom: gl.getUniformLocation(program, "u_zoom"),
    maxSteps: gl.getUniformLocation(program, "u_maxSteps"),
    epsilon: gl.getUniformLocation(program, "u_epsilon"),
    fractalIter: gl.getUniformLocation(program, "u_fractalIter"),
    power: gl.getUniformLocation(program, "u_power"),
    aoSamples: gl.getUniformLocation(program, "u_aoSamples"),
};

// --- STATE & INPUTS ---

let startTime = performance.now();
let lastFrameTime = startTime;
let frameCount = 0;
let isDead = false;

// Camera State
let camLat = 0.0; // Latitude (Pitch)
let camLon = -1.5; // Longitude (Yaw)
let camDist = 2.5;
let zoom = 2.0;

// Input State
let isDragging = false;
let lastMouseX = 0;
let lastMouseY = 0;
const keys = {};

// Difficulty Curve Configuration
const BENCHMARK_DURATION = 60; // Seconds until death
const MAX_RES_MULTIPLIER = 4.0; // At death, render 4x resolution (16x pixels)

window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);

// Mouse/Touch Logic
const handleStart = (x, y) => { isDragging = true; lastMouseX = x; lastMouseY = y; };
const handleMove = (x, y) => {
    if (!isDragging) return;
    const dx = x - lastMouseX;
    const dy = y - lastMouseY;
    camLon -= dx * 0.01;
    camLat = Math.max(-1.5, Math.min(1.5, camLat + dy * 0.01));
    lastMouseX = x;
    lastMouseY = y;
};
const handleEnd = () => { isDragging = false; };

canvas.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
window.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
window.addEventListener('mouseup', handleEnd);

canvas.addEventListener('touchstart', e => {
    if (e.touches.length === 1) handleStart(e.touches[0].clientX, e.touches[0].clientY);
}, {passive: false});
canvas.addEventListener('touchmove', e => {
    e.preventDefault(); // Prevent scrolling
    if (e.touches.length === 1) handleMove(e.touches[0].clientX, e.touches[0].clientY);
}, {passive: false});
canvas.addEventListener('touchend', handleEnd);

// Zoom (Wheel)
canvas.addEventListener('wheel', e => {
    zoom += e.deltaY * -0.002;
    zoom = Math.max(0.1, Math.min(10.0, zoom));
}, {passive: true});

// Double tap reset
let lastTap = 0;
canvas.addEventListener('touchend', e => {
    const now = new Date().getTime();
    if (now - lastTap < 300) {
        camLat = 0; camLon = -1.5; zoom = 2.0; startTime = performance.now(); // Soft reset
    }
    lastTap = now;
});

// --- MAIN LOOP ---

function render(now) {
    if(isDead) return;

    const elapsedTotal = (now - startTime) / 1000;
    const deltaTime = now - lastFrameTime;
    lastFrameTime = now;
    frameCount++;

    // --- DIFFICULTY CALCULATION (The "Kill" Logic) ---
    
    // Normalize progress 0.0 -> 1.0 over 60 seconds
    let progress = Math.min(elapsedTotal / BENCHMARK_DURATION, 1.0);
    
    // Exponential curves
    // 0s: Steps 64, Epsilon 0.01
    // 30s: Steps 200, Epsilon 0.001
    // 50s: Steps 1000, Epsilon 0.0001
    // 60s+: Steps 4000+, Epsilon 0.000001, ResScale 4x
    
    // If we passed the limit, kill mode
    let killMode = elapsedTotal > BENCHMARK_DURATION;

    let maxSteps = Math.floor(64 + Math.pow(progress, 3.0) * 2000);
    let epsilon = 0.005 * Math.pow(0.1, progress * 3.0); 
    let iter = 4 + Math.floor(progress * 16); // Fractal detail
    let ao = 2 + Math.floor(progress * 8);
    
    // Resolution Scaling (Super-Sampling)
    // Start at 1.0, stay 1.0 until 40s, then ramp to 4.0x
    let resScale = 1.0;
    if (progress > 0.7) {
        resScale = 1.0 + (progress - 0.7) * 10.0; // Ramps to 4.0 quickly
    }
    
    if (killMode) {
        maxSteps = 5000; // Shader loop limit
        epsilon = 0.0000001;
        iter = 25;
        ao = 10;
        resScale = MAX_RES_MULTIPLIER; // 16x pixels
        document.getElementById('warning').style.display = 'block';
    }

    // Resize Canvas
    const displayWidth  = window.innerWidth;
    const displayHeight = window.innerHeight;
    
    // Actual render buffer size
    const bufferWidth = Math.floor(displayWidth * window.devicePixelRatio * resScale);
    const bufferHeight = Math.floor(displayHeight * window.devicePixelRatio * resScale);

    if (canvas.width !== bufferWidth || canvas.height !== bufferHeight) {
        canvas.width = bufferWidth;
        canvas.height = bufferHeight;
    }

    gl.viewport(0, 0, canvas.width, canvas.height);

    // --- UPDATE CAMERA ---
    
    // Auto rotate if idle
    if (!isDragging) {
        camLon += 0.002 * (1.0 + progress); // Spin faster as it gets harder
    }

    // Keyboard Pan
    if(keys['KeyW'] || keys['ArrowUp']) camLat += 0.02;
    if(keys['KeyS'] || keys['ArrowDown']) camLat -= 0.02;
    if(keys['KeyA'] || keys['ArrowLeft']) camLon -= 0.02;
    if(keys['KeyD'] || keys['ArrowRight']) camLon += 0.02;

    // Convert spherical to cartesian
    const cx = Math.cos(camLat) * Math.cos(camLon) * camDist;
    const cy = Math.sin(camLat) * camDist;
    const cz = Math.cos(camLat) * Math.sin(camLon) * camDist;

    // --- DRAW ---

    gl.useProgram(program);
    gl.bindVertexArray(vao);

    gl.uniform2f(locs.res, canvas.width, canvas.height);
    gl.uniform1f(locs.time, elapsedTotal);
    gl.uniform3f(locs.camPos, cx, cy, cz);
    gl.uniform3f(locs.camTarget, 0, 0, 0);
    gl.uniform1f(locs.zoom, zoom);
    
    // Difficulty Uniforms
    gl.uniform1i(locs.maxSteps, maxSteps);
    gl.uniform1f(locs.epsilon, epsilon);
    gl.uniform1i(locs.fractalIter, iter);
    gl.uniform1f(locs.power, 8.0 + Math.sin(elapsedTotal * 0.5)); // Animating power adds noise
    gl.uniform1i(locs.aoSamples, ao);

    gl.drawArrays(gl.TRIANGLES, 0, 6);

    // --- UPDATE HUD ---
    
    if (frameCount % 5 === 0) { // Don't update DOM every frame
        const fps = 1000 / deltaTime;
        document.getElementById('fps').innerText = fps.toFixed(1);
        document.getElementById('ms').innerText = deltaTime.toFixed(1) + ' ms';
        document.getElementById('frames').innerText = frameCount;
        document.getElementById('timer').innerText = elapsedTotal.toFixed(2) + 's';
        
        document.getElementById('load').innerText = Math.floor(progress * 100) + '%';
        document.getElementById('resScale').innerText = resScale.toFixed(2) + 'x';
        
        // Fake GFLOPS calc based on pixels * steps * iter
        const ops = (canvas.width * canvas.height * maxSteps * iter) / 1000000000;
        document.getElementById('gflops').innerText = ops.toFixed(2);

        document.getElementById('steps').innerText = maxSteps;
        document.getElementById('epsilon').innerText = epsilon.toFixed(7);
        document.getElementById('iter').innerText = iter;
        document.getElementById('ao').innerText = ao;

        // Color code FPS
        const fpsEl = document.getElementById('fps');
        if(fps < 30) fpsEl.style.color = 'red';
        else if(fps < 55) fpsEl.style.color = 'yellow';
        else fpsEl.style.color = '#0f0';
    }

    // Check for WebGL context loss (The ultimate success condition)
    if (gl.isContextLost()) {
        isDead = true;
        document.getElementById('warning').innerText = "BENCHMARK COMPLETE: GPU CRASHED";
        document.getElementById('warning').style.display = 'block';
    }

    requestAnimationFrame(render);
}

requestAnimationFrame(render);

</script>
</body>
</html>